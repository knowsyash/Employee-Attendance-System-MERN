const express = require("express");
const crypto = require("crypto");
const SecretKey = require("../models/SecretKey");
const { verifyToken, requireMinRole } = require("../middleware/rbac");

const router = express.Router();

// Role hierarchy for key generation permissions
const roleHierarchy = {
  super_admin: 5,
  admin: 4,
  manager: 3,
  hr: 2,
  employee: 1,
};

// Get roles that the current user can generate keys for
// Note: super_admin cannot be registered through API, so it's excluded
const getGeneratableRoles = (userRole) => {
  const userLevel = roleHierarchy[userRole] || 0;
  const roles = [];

  // Only roles that can be registered through API
  if (userLevel > roleHierarchy.employee) roles.push("employee");
  if (userLevel > roleHierarchy.hr) roles.push("hr");
  if (userLevel > roleHierarchy.manager) roles.push("manager");
  if (userLevel > roleHierarchy.admin) roles.push("admin");
  // super_admin is excluded - can only be created from backend

  return roles;
};

// Generate a new secret key for a specific role
router.post("/generate", verifyToken, async (req, res) => {
  try {
    const { role, expiresInDays, classroom } = req.body;
    const userRole = req.user.role;
    const userClassroom = req.user.classroom;

    // Check if user can generate keys (not employee)
    if (userRole === "employee") {
      return res.status(403).json({ 
        message: "Employees cannot generate secret keys" 
      });
    }

    // Validate role (super_admin excluded - backend only)
    if (!role || !["admin", "manager", "hr", "employee"].includes(role)) {
      return res.status(400).json({ 
        message: "Invalid role. Must be one of: admin, manager, hr, employee. Super admin can only be created from backend." 
      });
    }

    // Check if user can generate key for this role
    const generatableRoles = getGeneratableRoles(userRole);
    if (!generatableRoles.includes(role)) {
      return res.status(403).json({ 
        message: `You don't have permission to generate keys for ${role} role` 
      });
    }

    // Determine classroom for the key
    let keyClassroom = null;
    
    // Super admin can specify classroom, others inherit their classroom
    if (userRole === "super_admin") {
      // Super admin can create keys for any classroom or new classroom
      keyClassroom = classroom || null;
    } else {
      // Other roles inherit their classroom
      keyClassroom = userClassroom;
    }

    // For admin role, classroom is required
    if (role === "admin" && !keyClassroom) {
      return res.status(400).json({ 
        message: "Classroom is required when generating admin key" 
      });
    }

    // Generate secure random key
    const secretKey = crypto.randomBytes(32).toString("hex");

    // Calculate expiration date
    const expiresAt = expiresInDays 
      ? new Date(Date.now() + expiresInDays * 24 * 60 * 60 * 1000)
      : null;

    // Save key to database
    const keyRecord = new SecretKey({
      key: secretKey,
      role: role,
      classroom: keyClassroom,
      generatedBy: req.user._id,
      generatedByRole: userRole,
      generatedByClassroom: userClassroom,
      expiresAt: expiresAt,
    });

    await keyRecord.save();

    res.status(201).json({
      message: `Secret key generated for ${role} role${keyClassroom ? ` in classroom: ${keyClassroom}` : ''}`,
      secretKey: secretKey,
      role: role,
      classroom: keyClassroom,
      expiresAt: expiresAt,
      createdAt: keyRecord.createdAt,
    });
  } catch (error) {
    console.error("Error generating secret key:", error);
    res.status(500).json({ 
      message: "Server error", 
      error: error.message 
    });
  }
});

// Get all secret keys generated by current user
router.get("/my-keys", verifyToken, async (req, res) => {
  try {
    const userRole = req.user.role;
    const userClassroom = req.user.classroom;

    if (userRole === "employee") {
      return res.status(403).json({ 
        message: "Employees cannot view secret keys" 
      });
    }

    // Super admin can see all keys, others only see their classroom keys
    const filter = { generatedBy: req.user._id };
    if (userRole !== "super_admin" && userClassroom) {
      filter.classroom = userClassroom;
    }

    const keys = await SecretKey.find(filter)
      .populate("usedBy", "name email classroom")
      .sort({ createdAt: -1 });

    res.json(keys);
  } catch (error) {
    res.status(500).json({ 
      message: "Server error", 
      error: error.message 
    });
  }
});

// Get all active secret keys (for admins)
router.get("/all", verifyToken, requireMinRole("admin"), async (req, res) => {
  try {
    const { role, isActive } = req.query;
    const filter = {};

    if (role) filter.role = role;
    if (isActive !== undefined) filter.isActive = isActive === "true";

    const keys = await SecretKey.find(filter)
      .populate("generatedBy", "name email role")
      .populate("usedBy", "name email")
      .sort({ createdAt: -1 });

    res.json(keys);
  } catch (error) {
    res.status(500).json({ 
      message: "Server error", 
      error: error.message 
    });
  }
});

// Deactivate a secret key
router.put("/:id/deactivate", verifyToken, async (req, res) => {
  try {
    const keyRecord = await SecretKey.findById(req.params.id);

    if (!keyRecord) {
      return res.status(404).json({ message: "Secret key not found" });
    }

    // Only the generator or admin can deactivate
    if (keyRecord.generatedBy.toString() !== req.user._id.toString() && 
        !["super_admin", "admin"].includes(req.user.role)) {
      return res.status(403).json({ 
        message: "You don't have permission to deactivate this key" 
      });
    }

    keyRecord.isActive = false;
    await keyRecord.save();

    res.json({ 
      message: "Secret key deactivated successfully",
      key: keyRecord 
    });
  } catch (error) {
    res.status(500).json({ 
      message: "Server error", 
      error: error.message 
    });
  }
});

// Get roles that current user can generate keys for
router.get("/generatable-roles", verifyToken, async (req, res) => {
  try {
    const userRole = req.user.role;

    if (userRole === "employee") {
      return res.json({ roles: [] });
    }

    const roles = getGeneratableRoles(userRole);
    res.json({ roles });
  } catch (error) {
    res.status(500).json({ 
      message: "Server error", 
      error: error.message 
    });
  }
});

module.exports = router;

